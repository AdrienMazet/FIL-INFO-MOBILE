"use strict";

var assert = require("assert");

var fs = require("fs");

var http = require("http");

var https = require("https");

var tls = require("tls");

var net = require("net");

var sinon = require("sinon");

var app = require("../index.js")();

var certs = require("../certs.js");

var HTTPS_PORT = 4443;
var HTTP_PORT = 8080; // make an http request on the specified path

function makeRequest() {
  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "/";
  var secure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var port = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : HTTPS_PORT;
  var options = {
    host: "localhost",
    port: port,
    path: path,
    method: "GET",
    headers: {
      "accept-encoding": "gzip"
    },
    rejectUnauthorized: false
  };
  var protocol = secure ? https : http;
  return new Promise(function (resolve, reject) {
    protocol.request(options, function (resp) {
      var data = ""; // eslint-disable-next-line no-return-assign

      resp.on("data", function (chunk) {
        return data += chunk;
      });
      resp.on("end", function () {
        return resolve({
          data: data,
          statusCode: resp.statusCode,
          headers: resp.headers
        });
      });
    }).on("error", function (err) {
      return reject(err);
    }).end();
  });
} // TEST CERTFICATES


describe("Testing certs", function () {
  // timeout 5 min, since requires the mkcert executable download
  this.timeout(300000);
  it("can be uninstalled", function () {
    certs.remove();
  });
  it("uninstall is idempotent (doesn't fail if called twice)", function () {
    certs.remove();
  });
  it("can be installed", function (done) {
    certs.generate().then(done);
  });
  it("can be installed at first run", function (done) {
    // inner async function
    (function _callee() {
      return regeneratorRuntime.async(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // remove certs
              certs.remove(); // prepare the server with a mock response

              app.get("/test/module", function (req, res) {
                return res.send("TEST");
              }); // start the server

              _context.next = 4;
              return regeneratorRuntime.awrap(app.listen(HTTPS_PORT));

            case 4:
              _context.next = 6;
              return regeneratorRuntime.awrap(makeRequest("/test/module").then(function (res) {
                return assert(res.data === "TEST");
              }));

            case 6:
              // close the server
              app.server.close();
              done();

            case 8:
            case "end":
              return _context.stop();
          }
        }
      });
    })();
  });
  it("can be installed in custom folder", function (done) {
    // inner async function
    (function _callee2() {
      return regeneratorRuntime.async(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              // set a custom cert path
              process.env.CERT_PATH = "test/custom-folder"; // prepare the server with a mock response

              app.get("/test/module", function (req, res) {
                return res.send("TEST");
              }); // start the server

              _context2.next = 4;
              return regeneratorRuntime.awrap(app.listen(HTTPS_PORT));

            case 4:
              _context2.next = 6;
              return regeneratorRuntime.awrap(makeRequest("/test/module").then(function (res) {
                return assert(res.data === "TEST");
              }));

            case 6:
              // close the server
              app.server.close(); // restore the CERT_PATH to undefined

              delete process.env.CERT_PATH;
              done();

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      });
    })();
  });
  it("crashes if certs doesn't exists in custom folder", function (done) {
    // inner async function
    (function _callee3() {
      return regeneratorRuntime.async(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              // set a custom cert path
              process.env.CERT_PATH = "test/custom-folder"; // remove the certificates

              fs.unlinkSync("test/custom-folder/localhost.crt");
              fs.unlinkSync("test/custom-folder/localhost.key"); // stub the exit function

              sinon.stub(process, "exit"); // listen

              _context3.next = 6;
              return regeneratorRuntime.awrap(app.listen(HTTPS_PORT));

            case 6:
              // should exit 1
              assert(process.exit.calledWith(1));
              process.exit.restore(); // close the server

              app.server.close(); // delete the custom folder

              certs.remove(process.env.CERT_PATH); // restore the CERT_PATH to undefined

              delete process.env.CERT_PATH;
              done();

            case 12:
            case "end":
              return _context3.stop();
          }
        }
      });
    })();
  });
  it("support path with spaces", function (done) {
    // inner async function
    (function _callee4() {
      return regeneratorRuntime.async(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              // set a custom cert path
              process.env.CERT_PATH = "test/custom folder"; // prepare the server with a mock response

              app.get("/test/module", function (req, res) {
                return res.send("TEST");
              }); // start the server

              _context4.next = 4;
              return regeneratorRuntime.awrap(app.listen(HTTPS_PORT));

            case 4:
              _context4.next = 6;
              return regeneratorRuntime.awrap(makeRequest("/test/module").then(function (res) {
                return assert(res.data === "TEST");
              }));

            case 6:
              // close the server
              app.server.close(); // delete the custom folder

              certs.remove(process.env.CERT_PATH); // restore the CERT_PATH to undefined

              delete process.env.CERT_PATH;
              done();

            case 10:
            case "end":
              return _context4.stop();
          }
        }
      });
    })();
  });
  it("provides the certificate", function (done) {
    // inner async function
    (function _callee5() {
      var appCerts, realCerts;
      return regeneratorRuntime.async(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return regeneratorRuntime.awrap(app.getCerts());

            case 2:
              appCerts = _context5.sent;
              _context5.next = 5;
              return regeneratorRuntime.awrap(certs.getCerts());

            case 5:
              realCerts = _context5.sent;
              assert.deepStrictEqual(appCerts, realCerts);
              done();

            case 8:
            case "end":
              return _context5.stop();
          }
        }
      });
    })();
  });
  it("works with environment domain", function (done) {
    (function _callee6() {
      var appCerts, secureContext, secureSocket, cert, certDomain;
      return regeneratorRuntime.async(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              // set the environment domain
              process.env.HOST = "192.168.0.1"; // Get the cert

              _context6.next = 3;
              return regeneratorRuntime.awrap(app.getCerts());

            case 3:
              appCerts = _context6.sent;
              // Configure the cert to be able to read it
              secureContext = tls.createSecureContext({
                cert: appCerts.cert
              });
              secureSocket = new tls.TLSSocket(new net.Socket(), {
                secureContext: secureContext
              }); // Read the cert and parse out the domain

              cert = secureSocket.getCertificate();
              certDomain = cert.subjectaltname.split(":")[1]; // Compare the domains

              assert(certDomain === process.env.HOST);
              done();

            case 10:
            case "end":
              return _context6.stop();
          }
        }
      });
    })();
  });
}); // TESTS MODULE

describe("Testing module", function () {
  // close the server after each test
  afterEach(function () {
    app.server.close();
    delete process.env.PORT;
  });
  it("works as express app", function (done) {
    (function _callee7() {
      return regeneratorRuntime.async(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              // prepare the server with a mock response
              app.get("/test/module", function (req, res) {
                return res.send("TEST");
              }); // start the server

              _context7.next = 3;
              return regeneratorRuntime.awrap(app.listen(HTTPS_PORT));

            case 3:
              _context7.next = 5;
              return regeneratorRuntime.awrap(makeRequest("/test/module").then(function (res) {
                return assert(res.data === "TEST");
              }));

            case 5:
              done();

            case 6:
            case "end":
              return _context7.stop();
          }
        }
      });
    })();
  });
  it("works with environment port", function (done) {
    (function _callee8() {
      return regeneratorRuntime.async(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              // prepare the server with a mock response
              app.get("/test/module", function (req, res) {
                return res.send("TEST");
              }); // set the environment port

              process.env.PORT = HTTPS_PORT; // start the server

              _context8.next = 4;
              return regeneratorRuntime.awrap(app.listen());

            case 4:
              _context8.next = 6;
              return regeneratorRuntime.awrap(makeRequest("/test/module").then(function (res) {
                return assert(res.data === "TEST");
              }));

            case 6:
              done();

            case 7:
            case "end":
              return _context8.stop();
          }
        }
      });
    })();
  });
}); // TEST SCRIPT

describe("Testing serve", function () {
  // close the server after each test
  afterEach(function () {
    app.server.close();
    delete process.env.PORT;
  });
  it("serves static files from custom path", function (done) {
    (function _callee9() {
      return regeneratorRuntime.async(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              // start the server (serving the test folder)port 443 or port 80
              app.serve("test", HTTPS_PORT); // make the request and check the output

              _context9.next = 3;
              return regeneratorRuntime.awrap(makeRequest("/static.html").then(function (res) {
                return assert(res.data.toString() === fs.readFileSync("test/static.html").toString());
              }));

            case 3:
              done();

            case 4:
            case "end":
              return _context9.stop();
          }
        }
      });
    })();
  });
  it("serves static files from default env port", function (done) {
    (function _callee10() {
      return regeneratorRuntime.async(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              // set the environment port
              process.env.PORT = HTTPS_PORT; // start the server (serving the default folder)

              app.serve("test"); // make the request and check the output

              _context10.next = 4;
              return regeneratorRuntime.awrap(makeRequest("/static.html").then(function (res) {
                return assert(res.data.toString() === fs.readFileSync("test/static.html").toString());
              }));

            case 4:
              done();

            case 5:
            case "end":
              return _context10.stop();
          }
        }
      });
    })();
  });
  it("includes access-control-allow-origin header", function (done) {
    (function _callee11() {
      return regeneratorRuntime.async(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              // set the environment port
              process.env.PORT = HTTPS_PORT; // start the server (serving the default folder)

              app.serve("test"); // make the request and check the output

              _context11.next = 4;
              return regeneratorRuntime.awrap(makeRequest("/static.html").then(function (res) {
                return assert(res.headers["access-control-allow-origin"] === "*");
              }));

            case 4:
              done();

            case 5:
            case "end":
              return _context11.stop();
          }
        }
      });
    })();
  });
  it("doesn't crash on 404", function (done) {
    (function _callee12() {
      return regeneratorRuntime.async(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              // set the environment port
              process.env.PORT = HTTPS_PORT; // start the server (serving the default folder)

              app.serve(); // make the request and check the status code

              _context12.next = 4;
              return regeneratorRuntime.awrap(makeRequest("/do-not-exist").then(function (res) {
                return assert(res.statusCode === 404);
              }));

            case 4:
              done();

            case 5:
            case "end":
              return _context12.stop();
          }
        }
      });
    })();
  });
  it("looks for a 404.html file", function (done) {
    (function _callee13() {
      return regeneratorRuntime.async(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return regeneratorRuntime.awrap(app.serve("test", HTTPS_PORT));

            case 2:
              _context13.next = 4;
              return regeneratorRuntime.awrap(makeRequest("/do-not-exist.html").then(function (res) {
                assert(res.statusCode === 404);
                assert(res.data.toString() === fs.readFileSync("test/404.html").toString());
              }));

            case 4:
              done();

            case 5:
            case "end":
              return _context13.stop();
          }
        }
      });
    })();
  });
  it("doesn't crash if the static path doesn't exists", function (done) {
    (function _callee14() {
      return regeneratorRuntime.async(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              // start the server (serving a non existing folder)
              app.serve("does-not-exist", HTTPS_PORT); // make the request and check the status code

              _context14.next = 3;
              return regeneratorRuntime.awrap(makeRequest("/").then(function (res) {
                return assert(res.statusCode === 404);
              }));

            case 3:
              done();

            case 4:
            case "end":
              return _context14.stop();
          }
        }
      });
    })();
  });
}); // TEST REDIRECT

describe("Testing redirect", function () {
  // close the server after each test
  afterEach(function () {
    app.http.close();
    delete process.env.PORT;
  });
  it("redirect http to https", function (done) {
    (function _callee15() {
      return regeneratorRuntime.async(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 2;
              return regeneratorRuntime.awrap(app.redirect(HTTP_PORT));

            case 2:
              _context15.next = 4;
              return regeneratorRuntime.awrap(makeRequest("/", false, HTTP_PORT).then(function (res) {
                assert(res.statusCode === 301);
                assert(res.headers.location === "https://localhost/");
              }));

            case 4:
              done();

            case 5:
            case "end":
              return _context15.stop();
          }
        }
      });
    })();
  });
  it("redirect http to https with custom ports", function (done) {
    (function _callee16() {
      return regeneratorRuntime.async(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return regeneratorRuntime.awrap(app.redirect(HTTP_PORT, HTTPS_PORT));

            case 2:
              _context16.next = 4;
              return regeneratorRuntime.awrap(makeRequest("/", false, HTTP_PORT).then(function (res) {
                assert(res.statusCode === 301);
                assert(res.headers.location === "https://localhost:4443/");
              }));

            case 4:
              done();

            case 5:
            case "end":
              return _context16.stop();
          }
        }
      });
    })();
  });
  it("redirect http to https with env port", function (done) {
    (function _callee17() {
      return regeneratorRuntime.async(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              // set the environment port
              process.env.PORT = HTTPS_PORT; // start the redirection

              _context17.next = 3;
              return regeneratorRuntime.awrap(app.redirect(HTTP_PORT));

            case 3:
              _context17.next = 5;
              return regeneratorRuntime.awrap(makeRequest("/", false, HTTP_PORT).then(function (res) {
                assert(res.statusCode === 301);
                assert(res.headers.location === "https://localhost:4443/");
              }));

            case 5:
              done();

            case 6:
            case "end":
              return _context17.stop();
          }
        }
      });
    })();
  });
}); // OTHER TESTS

describe("Testing additional features", function () {
  // timeout 10 secs, since sometimes 3 secs are not sufficient
  this.timeout(10000);
  it("is ready for production", function (done) {
    (function _callee18() {
      return regeneratorRuntime.async(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              // set NODE_ENV to production
              delete require.cache[require.resolve("../index.js")];
              process.env.NODE_ENV = "production";
              app = require("../index.js")(); // start the server (serving the test folder)

              app.serve("test", HTTPS_PORT); // make the request and check the output

              _context18.next = 6;
              return regeneratorRuntime.awrap(makeRequest("/static.html").then(function (res) {
                return assert(res.headers["content-encoding"] === "gzip");
              }));

            case 6:
              // reset NODE_ENV and app
              delete require.cache[require.resolve("../index.js")];
              delete process.env.NODE_ENV;
              app = require("../index.js")();
              done();

            case 10:
            case "end":
              return _context18.stop();
          }
        }
      });
    })();
  });
});