#!/usr/bin/env node
"use strict";

var path = require("path");

var fs = require("fs");

var exec = require("child_process").exec;

var https = require("https");

var getAppDataPath = require("appdata-path");

var MKCERT_VERSION = "v1.4.3";
var CERT_PATH = getAppDataPath("https-localhost"); // check for updates

/* istanbul ignore next: cannot test pkg */

function checkUpdates() {
  try {
    var options = {
      host: "api.github.com",
      path: "/repos/daquinoaldo/https-localhost/releases/latest",
      method: "GET",
      headers: {
        "User-Agent": "node.js"
      }
    };
    https.request(options, function (res) {
      var body = "";
      res.on("data", function (chunk) {
        body += chunk.toString("utf8");
      });
      res.on("end", function () {
        var currentVersion = JSON.parse(fs.readFileSync(path.resolve(__dirname, "package.json"))).version;
        var latestVersion = JSON.parse(body).tag_name.replace("v", "");
        if (currentVersion !== latestVersion) console.warn("[https-localhost] New update available.");
      });
    }).end();
  } catch (e) {// Just catch everything, this is not a critic part and can fail.
    // It is important to not affect the script behavior.
  }
} // get the executable name


function getExe() {
  /* istanbul ignore next: tested on all platform on travis */
  switch (process.platform) {
    case "darwin":
      return "mkcert-" + MKCERT_VERSION + "-darwin-amd64";

    case "linux":
      if (process.arch === "arm" || process.arch === "arm64") return "mkcert-" + MKCERT_VERSION + "-linux-arm";else return "mkcert-" + MKCERT_VERSION + "-linux-amd64";

    /* falls through */

    case "win32":
      return "mkcert-" + MKCERT_VERSION + "-windows-amd64.exe";

    default:
      console.warn("Cannot generate the localhost certificate on your " + "platform. Please, consider contacting the developer if you can help.");
      process.exit(0);
  }
} // download a binary file


function download(url, path) {
  console.log("Downloading the mkcert executable...");
  var file = fs.createWriteStream(path);
  return new Promise(function (resolve) {
    function get(url, file) {
      https.get(url, function (response) {
        if (response.statusCode === 302) get(response.headers.location, file);else response.pipe(file).on("finish", resolve);
      });
    }

    get(url, file);
  });
} // execute the binary executable to generate the certificates


function mkcert(appDataPath, exe, domain) {
  var escapeSpaces, exePath, crtPath, keyPath, cmd;
  return regeneratorRuntime.async(function mkcert$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          // fix problems with spaces

          /* istanbul ignore next: platform dependent */
          escapeSpaces = function escapeSpaces(path) {
            // escape spaces (not already escaped)
            if (process.platform === "darwin" || process.platform === "linux") return path.replace(/(?<!\\) /g, "\\ "); // use apex on Windows

            if (process.platform === "win32") return "\"" + path + "\"";
            return path;
          };

          exePath = escapeSpaces(path.join(appDataPath, exe));
          crtPath = escapeSpaces(path.join(appDataPath, domain + ".crt"));
          keyPath = escapeSpaces(path.join(appDataPath, domain + ".key"));
          cmd = "".concat(exePath, " -install -cert-file ").concat(crtPath) + " -key-file ".concat(keyPath, " ").concat(domain); // sleep on windows due to issue #28

          /* istanbul ignore if: cannot be tested */

          if (!(process.platform === "win32")) {
            _context.next = 8;
            break;
          }

          _context.next = 8;
          return regeneratorRuntime.awrap(new Promise(function (resolve) {
            return setTimeout(resolve, 3000);
          }));

        case 8:
          return _context.abrupt("return", new Promise(function (resolve, reject) {
            console.log("Running mkcert to generate certificates..."); // run the mkcert command

            exec(cmd, function (err, stdout, stderr) {
              /* istanbul ignore if: cannot be tested */
              if (stdout) console.log(stdout);
              /* istanbul ignore next: cannot be tested */

              if (stderr) console.error(stderr);
              /* istanbul ignore if: cannot be tested */

              if (err) {
                console.error(err);
                reject(err);
              }

              resolve();
            });
          }));

        case 9:
        case "end":
          return _context.stop();
      }
    }
  });
}

function generate() {
  var appDataPath,
      customDomain,
      domain,
      url,
      exe,
      exePath,
      _args2 = arguments;
  return regeneratorRuntime.async(function generate$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          appDataPath = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : CERT_PATH;
          customDomain = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : undefined;
          domain = customDomain || "localhost";
          console.info("Generating certificates...");
          console.log("Certificates path: " + appDataPath + ". Never modify nor share this files."); // mkdir if not exists

          /* istanbul ignore else: not relevant */

          if (!fs.existsSync(appDataPath)) fs.mkdirSync(appDataPath, {
            recursive: true
          }); // build the executable url and path

          url = "https://github.com/FiloSottile/mkcert/releases/download/" + MKCERT_VERSION + "/";
          exe = getExe();
          exePath = path.join(appDataPath, exe); // download the executable

          _context2.next = 11;
          return regeneratorRuntime.awrap(download(url + exe, exePath));

        case 11:
          // make binary executable
          fs.chmodSync(exePath, "0755"); // execute the binary

          _context2.next = 14;
          return regeneratorRuntime.awrap(mkcert(appDataPath, exe, domain));

        case 14:
          console.log("Certificates generated, installed and trusted. Ready to go!");

        case 15:
        case "end":
          return _context2.stop();
      }
    }
  });
}

function getCerts() {
  var customDomain,
      domain,
      certPath,
      _args3 = arguments;
  return regeneratorRuntime.async(function getCerts$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          customDomain = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : undefined;
          domain = process.env.HOST || customDomain || "localhost";
          certPath = process.env.CERT_PATH || CERT_PATH; // check for updates if running as executable

          /* istanbul ignore if: cannot test pkg */

          if (process.pkg) checkUpdates(); // check if a reinstall is forced or needed by a mkcert update

          if (!(process.env.REINSTALL || !fs.existsSync(path.join(certPath, getExe())))) {
            _context3.next = 7;
            break;
          }

          _context3.next = 7;
          return regeneratorRuntime.awrap(generate(certPath, domain));

        case 7:
          _context3.prev = 7;
          return _context3.abrupt("return", {
            key: fs.readFileSync(path.join(certPath, domain + ".key")),
            cert: fs.readFileSync(path.join(certPath, domain + ".crt"))
          });

        case 11:
          _context3.prev = 11;
          _context3.t0 = _context3["catch"](7);

          if (!(certPath !== CERT_PATH)) {
            _context3.next = 18;
            break;
          }

          console.error("Cannot find localhost.key and localhost.crt in the" + " specified path: " + certPath);
          process.exit(1);
          _context3.next = 21;
          break;

        case 18:
          _context3.next = 20;
          return regeneratorRuntime.awrap(generate(CERT_PATH, domain));

        case 20:
          return _context3.abrupt("return", getCerts(domain));

        case 21:
        case "end":
          return _context3.stop();
      }
    }
  }, null, null, [[7, 11]]);
} // delete a folder and the file inside it


function remove() {
  var appDataPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : CERT_PATH;

  if (fs.existsSync(appDataPath)) {
    fs.readdirSync(appDataPath).forEach(function (file) {
      return fs.unlinkSync(path.join(appDataPath, file));
    });
    fs.rmdirSync(appDataPath);
  }
} // run as script

/* istanbul ignore if: cannot be tested */


if (require.main === module) // if run with -u or --uninstall
  if (process.argv.length === 3 && (process.argv[2] === "-u" || process.argv[2] === "--uninstall")) {
    remove();
    console.info("Certificates removed.");
  } else try {
    // install
    generate();
  } catch (err) {
    console.error("\nExec error: " + err);
  } // export as module

module.exports = {
  getCerts: getCerts,
  generate: generate,
  remove: remove
};